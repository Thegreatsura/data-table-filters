import { col as _col } from "./col";
import { presets } from "./presets";
import { deserializeSchema, serializeSchema } from "./serialize";
import { validateSchema } from "./validate";

/**
 * Column builder factories and presets for defining table schemas.
 *
 * **Primitive factories** — choose based on the data type of the column:
 * - `col.string()` — text data (`string`)
 * - `col.number()` — numeric data (`number`)
 * - `col.boolean()` — boolean data (`boolean`)
 * - `col.timestamp()` — date/time data (`Date`)
 * - `col.enum(values)` — string union (`T[number]`)
 * - `col.array(item)` — array of values (`U[]`)
 * - `col.record()` — key-value map (`Record<string, string>`)
 *
 * **Presets** — pre-configured builders for common log table patterns:
 * - `col.presets.logLevel(values)` — severity levels
 * - `col.presets.httpMethod(values)` — HTTP verbs
 * - `col.presets.httpStatus(codes?)` — HTTP status codes
 * - `col.presets.duration(unit?, slider?)` — timing / latency
 * - `col.presets.timestamp()` — sortable timestamp with timerange filter
 * - `col.presets.traceId()` — trace / request ID (code display, not filterable)
 * - `col.presets.pathname()` — URL path with text search
 *
 * @example
 * ```ts
 * import { col, createTableSchema } from "@/lib/table-schema";
 *
 * export const tableSchema = createTableSchema({
 *   level:   col.presets.logLevel(LEVELS).description("Log severity"),
 *   date:    col.presets.timestamp().label("Date").size(200).sheet(),
 *   latency: col.presets.duration("ms").label("Latency").sortable().size(110).sheet(),
 *   status:  col.presets.httpStatus().label("Status").size(60),
 *   method:  col.presets.httpMethod(METHODS).size(69),
 *   host:    col.string().label("Host").size(125).sheet(),
 *   headers: col.record().label("Headers").hidden().sheet(),
 * });
 * ```
 */
export const col = { ..._col, presets };
export type {
  ColBuilder,
  ColConfig,
  ColKind,
  ColumnDescriptor,
  DisplayConfig,
  FilterConfig,
  FilterDescriptor,
  FilterType,
  InferTableType,
  SchemaJSON,
  SheetConfig,
  SheetDescriptor,
  TableSchemaDefinition,
} from "./types";
export { generateColumns } from "./generators/columns";
export { generateFilterFields } from "./generators/filter-fields";
export { generateFilterSchema } from "./generators/filter-schema";
export { generateSheetFields } from "./generators/sheet-fields";
export { serializeSchema, deserializeSchema } from "./serialize";

/**
 * Derive defaultColumnVisibility from the schema.
 * Returns { [key]: false } for every column marked with .hidden().
 */
export function getDefaultColumnVisibility(
  schema: import("./types").TableSchemaDefinition,
): Record<string, boolean> {
  const visibility: Record<string, boolean> = {};
  for (const [key, builder] of Object.entries(schema)) {
    if (builder._config.hidden) {
      visibility[key] = false;
    }
  }
  return visibility;
}

/**
 * Create a table schema from a map of col.* builders.
 *
 * The returned object holds the definition and exposes:
 * - `toJSON()` — serializes the schema to a function-free JSON descriptor,
 *   suitable for AI agents, MCP tools, and `JSON.stringify`.
 *
 * Use `createTableSchema.fromJSON(json)` to reconstruct a schema from a
 * JSON descriptor (e.g. one generated by an AI agent). Custom renderers
 * (display.cell, filter.component, sheet.component) are not serialized and
 * must be applied manually on top of the reconstructed builders.
 *
 * @example
 * ```ts
 * export const tableSchema = createTableSchema({
 *   level: col.enum(LEVELS).label("Level").defaultOpen().sheet(),
 *   date: col.timestamp().label("Date").sortable().size(200).sheet(),
 * });
 *
 * export type ColumnSchema = InferTableType<typeof tableSchema.definition>;
 *
 * // Serialize for an AI agent or MCP tool
 * const json = tableSchema.toJSON();
 * // JSON.stringify(tableSchema) also works — toJSON() is called automatically
 *
 * // Reconstruct from AI-generated JSON
 * const schema = createTableSchema.fromJSON(json);
 * ```
 */
export function createTableSchema<
  T extends import("./types").TableSchemaDefinition,
>(definition: T): { definition: T; toJSON(): import("./types").SchemaJSON } {
  validateSchema(definition);
  return {
    definition,
    toJSON() {
      return serializeSchema(definition);
    },
  };
}

createTableSchema.fromJSON = (
  json: import("./types").SchemaJSON,
): {
  definition: import("./types").TableSchemaDefinition;
  toJSON(): import("./types").SchemaJSON;
} => {
  return createTableSchema(deserializeSchema(json));
};
